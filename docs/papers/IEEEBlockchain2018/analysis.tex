
%\subsubsection{Performance}
%\textcolor{red}{computational and communication costs (e.g., number of transactions, messages, contract-function calls, time complexity of solving and verification) and privacy}

\Aron{Note to self: extend!}
The computational cost of every smart-contract function is constant (i.e., $O(1)$) except for \texttt{finalize}, whose cost is an affine function of the size of the solution (i.e., $O(|A|)$).
Note that the cost of \texttt{finalize} depends on the size of the solution $A$ only because it emits an event for every assignment $\va \in A$.
These could be omitted for the sake of maximizing performance since the assignments have already been recorded in the blockchain anyway.
The number of function calls required for posting an offer depends on the number of resource types with non-zero quantity in the offer.
If there are $n$ such resource types, then $n + 2$ calls are required (\texttt{createOffer}, $n$ \texttt{updateOffer}, and \texttt{postOffer}).
The number of function calls required for submitting a solution $A$ is $1 + |A|$ (\texttt{createSolution} and $|A|$ \texttt{addAssignment}).


\subsubsection{Verification}
%\textcolor{red}{Describe how the properties were verified. Mention NuSMV - also provide hint what is the signficance of these properties}
%
For the specification of safety and liveness properties, we use Computation Tree Logic (CTL)~\cite{baier2008principles}. CTL formulas specify properties of execution trees generated by transitions systems. The formulas are built from atomic predicates that represent 
transitions and statements of the
transition system (i.e., smart contract), using several operators, such as $\mathtt{AX}$, $\mathtt{AF}$, $\mathtt{AG}$ (unary) and,
$\mathtt{A}[\cdot\,\mathtt{U}\,\cdot]$,
$\mathtt{A}[\cdot\,\mathtt{W}\,\cdot]$ (binary).  Each operator
consists of a quantifier on the branches of the tree and a temporal modality, which together define when in the execution the operand sub-formulas must hold.  The intuition behind the letters is the
following: the branch quantifier is $\mathtt{A}$ (for ``All'') and the temporal modalities are
$\mathtt{X}$ (for ``neXt''), $\mathtt{F}$ (for ``some time in the
Future''), $\mathtt{G}$ (for ``Globally''), 
$\mathtt{U}$ (for ``Until'') and $\mathtt{W}$ (for ``Weak until'').  
A property is satisfied if it holds in the initial state of the transition systems.  
For instance, the formula
$\mathtt{A}[p\,\mathtt{W}\,q]$ specifies that in \emph{all execution
  branches} the predicate $p$ must hold \emph{up to the first state}
(not including this latter) where the predicate $q$ holds.  
%
Since we used the weak until operator $\mathtt{W}$, if $q$ never
holds, $p$ must hold forever.
%
As soon
as $q$ holds in one state of an execution branch, $p$ does not need to hold
anymore, even if $q$ does not hold.  On the contrary, the formula
$\mathtt{AG}\,\mathtt{A}[p\,\mathtt{W}\,q]$ specifies that the
subformula $\mathtt{A}[p\,\mathtt{W}\,q]$ must hold in \emph{all
  branches at all times}.  Thus, $p$ must hold whenever $q$ does not hold, i.e., $\mathtt{AG}\,\mathtt{A}[p\,\mathtt{W}\,q] = \mathtt{AG}\,(p \lor q)$.
  %\Aron{Reference? I think that most reviewers will not be familiar with CTL.} \Anastasia{Added reference and small description of the operators}

We verified correctness of behavioral semantics with the NuSMV model checker~\cite{cimatti2002nusmv}, by verifying the following properties:
\begin{itemize}
    \item \emph{deadlock-freedom}, which ensures that the contract cannot enter a state in which progress is impossible;
    \item \emph{``if \texttt{close} happens, then \texttt{postOffer} or \texttt{cancelOffer} can happen only after \texttt{finalize}''}, translated to CTL as:\\ $\mathtt{AG}(\texttt{close})$ $\rightarrow$ $\mathtt{AX}$ $\mathtt{A}$ $[\neg ($\texttt{postOffer} $\wedge$ \texttt{cancelOffer}) $\mathtt{W}$ \texttt{finalize}$]$, which ensures that prosumers cannot post or cancel their offers once the solvers have started working;
    % \item \Aron{This cannot be true... What if no one every calls createSolution?!} \Anastasia{I have added fairness assumptions for the verification. In general we need fairness assumptions for the verification of liveness properties.} \emph{``\texttt{createSolution} will eventually happen after \texttt{postOffer}''}, which is translated to CTL as:\\
    % $\mathtt{AG}$ $($\texttt{createSolution} $\rightarrow$ $\mathtt{AF}$ $($\texttt{postOffer}$))$;
    % \item \emph{``\texttt{OfferCanceled} can happen only after \texttt{cancel}''}, which is translated to CTL as:\\ 
    % $\mathtt{A}[ \neg$ \texttt{OfferCanceled} $\mathtt{W}$ \texttt{cancel}$]$\Aron{I'm not sure what to say, this seems kinda obvious. This event is emitted only in this function, so the function obviously needs to be called before the event.};
    \item \emph{``\texttt{OfferPosted(ID)} can happen only if \texttt{ID < offers.length \&\& !offers[ID].posted}''}, translated to CTL as:\\ $\mathtt{A}[ \neg$\texttt{OfferPosted(ID)}$\mathtt{W}$ \texttt{ID < offers.length \&\& !offers[ID].posted}$]$, which ensures that an offer can be posted only if it has been created but not posted yet;
    \item \emph{``\texttt{OfferCanceled(ID)} can happen only if  \texttt{ID $<$ offers.length \&\&} \texttt{offers[ID].posted}''}, translated to CTL as:\\ $\mathtt{A}[ \neg$\texttt{OfferPosted(ID)}$\mathtt{W}$ \texttt{ID $<$ offers.length \&\& offers[ID].posted   }$]$, which ensures that an offer can be canceled only if it has been posted;
    \item \emph{``if \texttt{finalize} happens, then \texttt{createSolution} can happen only after \texttt{close}''}, translated to CTL as:\\ $\mathtt{AG}(\texttt{finalize})$ $\rightarrow$ $\mathtt{AX}$ $\mathtt{A}$ $[\neg$\texttt{createSolution} $\mathtt{W}$ \texttt{close}$]$, which ensures that solutions can be posted only in the solving phase.
    % \item \emph{``if \texttt{finalize} happens, then \texttt{addAssignment} can happen only after \texttt{createSolution}''}, translated to CTL as:\\ $\mathtt{AG}(\texttt{finalize})$ $\rightarrow$ $\mathtt{AX}$ $\mathtt{A}$ $[\neg$\texttt{addAssignment} $\mathtt{W}$ \texttt{createSolution}$]$, which ensures that assignments can be added only to existing solutions.
\end{itemize}

% after close happens, postOffer can happen only after finalize;
% after finalize happens, createSolution can happen only after close happens;
% after finalize happens, 
% addAssignment can happen only after createSolution happens

% \Anastasia{Are we going to post the generated code somewhere? Because for the last three verified properties we need it.}
% \Aron{Can we say something about how these properties were verified? Maybe mention NuSMV again?}
% \Anastasia{I mentioned NuSMV and a description of the CTL operators that we are using.}
% Section 5.1
% Analysis:
% - computational and communication costs (e.g., number of transactions, messages, contract-function calls, time complexity of solving and verification)
% - privacy

% Section 5.2
% Verification:
% - CTL properties (based on CSFâ€™18 submission)
